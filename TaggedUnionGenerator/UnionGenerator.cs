using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TaggedUnionGenerator.JsonConverterGen;
using TaggedUnionGenerator.UnionGen;
using TaggedUnionGenerator.Writers;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;

namespace TaggedUnionGenerator
{
    [Generator(LanguageNames.CSharp)]
    public class UnionGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput((ctx) =>
            {
                ctx.AddSource("UnionOptionAttribute`1.g.cs", Consts.UnionOptionAttrCode);
                ctx.AddSource("IUnion.g.cs", Consts.UnionInterfaceCode);
                ctx.AddSource("IUnion`1.g.cs", Consts.TypedUnionInterfaceCode);

                ctx.AddSource("UnionJsonConverterAttribute`1.g.cs", Consts.UnionJsonConverterCode);
                ctx.AddSource("UnionJsonConverterBase`2.g.cs", Consts.UnionJsonConverterBaseCode);
            });

            var unionCandidates = context.SyntaxProvider
                .ForAttributeWithMetadataName("SourceGenerator.UnionOptionAttribute`1",
                (node, _) => node is StructDeclarationSyntax sds && sds.Modifiers.Any(SyntaxKind.PartialKeyword),
                (ctx, _) =>
                {
                    var structDeclaration = (StructDeclarationSyntax)ctx.TargetNode;
                    var structSymbol = (INamedTypeSymbol)ctx.TargetSymbol;

                    return GetUnionDefinition(structSymbol, structDeclaration.GetLocation());
                })
                .WithTrackingName("unionCandidates");
            //    .WithComparer(new UnionTypeDefinitionEqualityComparer());

            var unionJsonConvertersCandidates = context.SyntaxProvider
                .ForAttributeWithMetadataName("SourceGenerator.UnionJsonConverterAttribute`1",
                (node, _) => node is ClassDeclarationSyntax sds && sds.Modifiers.Any(SyntaxKind.PartialKeyword),
                (ctx, _) =>
                {
                    var classSymbol = (INamedTypeSymbol)ctx.TargetSymbol;

                    var attribute = ctx.Attributes.Single(a => a.AttributeClass?.Name == "UnionJsonConverterAttribute");
                    var unionSymbol = (INamedTypeSymbol)attribute.AttributeClass!.TypeArguments.Single();

                    return new UnionTypeJsonConverterDefinition(
                        classSymbol.ContainingNamespace.IsGlobalNamespace
                            ? null
                            : classSymbol.ContainingNamespace.ToDisplayString(),
                        classSymbol.Name,
                        GetUnionDefinition(unionSymbol, null),
                        attribute.ApplicationSyntaxReference?.GetSyntax().GetLocation());

                })
                .WithTrackingName("unionJsonConvertersCandidates");


            context.RegisterSourceOutput(unionCandidates, (ctx, def) =>
            {
                if (!ValidateOptions(ctx, def))
                {
                    return;
                }

                try
                {
                    var sb = new StringBuilder();

                    using var textWriter = new StringWriter(sb, CultureInfo.InvariantCulture);
                    using var sourceWriter = new IndentedTextWriter(textWriter);

                    sourceWriter.WriteLine("//<auto-generated/>");
                    sourceWriter.WriteLine("#nullable enable");

                    UnionTypeWriter.Write(def, sourceWriter);

                    var code = sb.ToString();

                    ctx.AddSource($"{def.Name}.g.cs", code);
                }
                catch (Exception ex)
                {
                    var diag = Diagnostic.Create(Diagnostics.ErrorUnionGenerationGenericError, def.Location, def.Namespace, def.Name, ex);
                    ctx.ReportDiagnostic(diag);
                }
            });

            context.RegisterSourceOutput(unionJsonConvertersCandidates, (ctx, def) =>
            {
                if (def.UnionDefinition.Options.Length == 0)
                {
                    var diag = Diagnostic.Create(
                        Diagnostics.ErrorTypeIsNotAnUnion,
                        def.Location,
                        def.UnionDefinition.Namespace,
                        def.UnionDefinition.Name);

                    ctx.ReportDiagnostic(diag);
                    return;
                }

                try
                {
                    var sb = new StringBuilder();

                    using var textWriter = new StringWriter(sb, CultureInfo.InvariantCulture);
                    using var sourceWriter = new IndentedTextWriter(textWriter);

                    sourceWriter.WriteLine("//<auto-generated/>");
                    sourceWriter.WriteLine("#nullable enable");

                    UnionJsonSerializerTypeWriter.Write(def, sourceWriter);

                    var code = sb.ToString();

                    ctx.AddSource($"{def.Name}.g.cs", code);
                }
                catch (Exception ex)
                {
                    var diag = Diagnostic.Create(Diagnostics.ErrorSerializerGenerationGenericError, def.Location, def.Namespace, def.Name, ex);
                    ctx.ReportDiagnostic(diag);
                }

            });
        }

        private static UnionTypeDefinition GetUnionDefinition(INamedTypeSymbol structSymbol, Location? location)
        {
            var options = structSymbol.GetAttributes()
                .Where(a => a.AttributeClass.Name == "UnionOptionAttribute")
                .Select(a =>
                {
                    var loc = a.ApplicationSyntaxReference.GetSyntax().GetLocation();
                    var type = a.AttributeClass.TypeArguments.Single().ToDisplayString(Consts.GlobalAlias);
                    var name = (string)a.ConstructorArguments.Single().Value;

                    return new UnionTypeOptionDefinition(name, type, loc);
                })
                .ToImmutableArray();

            return new UnionTypeDefinition(
                structSymbol.ContainingNamespace.IsGlobalNamespace
                    ? null
                    : structSymbol.ContainingNamespace.ToDisplayString(),
                structSymbol.Name,
                options,
                location);
        }

        private static bool ValidateOptions(SourceProductionContext ctx, UnionTypeDefinition def)
        {
            var validationPassed = true;
            var optionUniqueCheck = new HashSet<string>();

            if (def.Options.Length < 2)
            {
                var diag = Diagnostic.Create(Diagnostics.ErrorSingleOptionServerNoPurpose, def.Location, def.Namespace, def.Name);

                ctx.ReportDiagnostic(diag);
            }

            foreach (var op in def.Options)
            {
                if (string.IsNullOrEmpty(op.Name))
                {
                    var diag = Diagnostic.Create(Diagnostics.ErrorEmptyOptionName, op.Location, def.Namespace, def.Name);

                    ctx.ReportDiagnostic(diag);
                    validationPassed = false;
                }
                else if (!optionUniqueCheck.Add(op.Name))
                {
                    var diag = Diagnostic.Create(Diagnostics.ErrorOptionNameUsedTwice, op.Location, def.Namespace, def.Name, op.Name);

                    ctx.ReportDiagnostic(diag);
                    validationPassed = false;
                }
                else if (!char.IsLetter(op.Name[0]) || !char.IsUpper(op.Name[0]))
                {
                    var diag = Diagnostic.Create(Diagnostics.ErrorInvalidOptionNameFormat, op.Location, def.Namespace, def.Name, op.Name);

                    ctx.ReportDiagnostic(diag);
                    validationPassed = false;
                }
            }

            return validationPassed;
        }

    }
}

